---
---

# This is the first parser implemented. It relies on a dependancy: bibtexParse.
# This parser parse bibtex files, likes the ones generated by Jabref or Zotero.
#
# Be aware that bibtexParse library is not perfect and some special content added by Jabref (for
# example groups) are not supported.

define(
  [
    'bibtexParse',
    './abstract'
  ],
  (bibtexParse, BibliographyParserAbstract) ->
    console.log("@@ Vinyl::Bibliography::Parser::BibTex @@ Initialisation...")
# Let's start extending the abstract base class
    class BibliographyParserBibtex extends BibliographyParserAbstract
      @specialChars = [
        #[/(?<!\)({|})/, ''],
        [/\\%/g, '%'],
        [/\\\$/g, '$'],
        [/\\{/g, '{'],
        [/\\_/g, '_'],
        [/\\P/g, ''], # TODO
        [/\\ddag/g, ''], #TODO
        [/\\textbar/g, '|'],
        [/\\textgreater/g, '&gt;'],
        [/\\textendash/g, '&ndash;'],
        [/--/g, '&ndash;'],
        [/\\texttrademark/g, ''], #TODO
        [/\\textexclamdown/g, '¡'],
        [/\\textsuperscript{(\w*)}/g, '<sup>$1</sup>'],
        [/\\pounds/g, '£'],
        [/\\#/g, '#'],
        [/\\&/g, '&amp;'],
        [/\\}/g, '}'],
        [/\\S/g, '§'],
        [/\\dag/g, ''], #TODO
        [/\\textbackslash/g, '\\'],
        [/\\textless/g, '&lt;'],
        [/\\textemdash/g, '&mdash;'],
        [/---/g, '&mdash'],
        [/\\textregistered/g, ''], # TODO
        [/\\textquestiondown/g, '¿'],
        [/\\textcircled{(\w*)}/g, '$1'], #TODO
        [/\\textcopyright/g, ''], #TODO
        [/\\textasciitilde{}/g, '~'],
        # Diacritics
        [/\\`{(.?)}/g, '$1&#x0300;'],
        [/\\'{(.?)}/g, '$1&#x0301;'],
        [/\\^{(.?)}/g, '$1&#x0302;'],
        [/\\"{(.?)}/g, '$1&#x0308;'],
        [/\\H{(.?)}/g, '$1&#x030B;'],
        [/\\~{(.?)}/g, '$1&#x0303;'],
        [/\\c{(.?)}/g, '$1&#x0327;'],
        [/\\k{(.?)}/g, '$1&#x0328;'],
        [/\\l{(.?)}/g, '$1&#x0335;'],
        [/\\={(.?)}/g, '$1&#x0304;'],
        [/\\b{(.?)}/g, '$1&#x0331;'],
        [/\\\.{(.?)}/g, '$1&#x0307;'],
        [/\\d{(.?)}/g, '$1&#x0323;'],
        [/\\r{(.?)}/g, '$1&#x030A;'],
        [/\\u{(.?)}/g, '$1&#x0306;'],
        [/\\v{(.?)}/g, '$1&#x030C;'],
        [/\\t{(..)}/g, '$1&#x0361;'],
        [/\\aa/g, 'a&#x030A;'],
        [/\\o/g, 'o&#x337;']
      ]

      constructor: () ->
        super("BibliographyParserBibtex")

# Implement/override the mandatory `parse` function.
# Then you can define as many functions as you want to do the actual job, but you HAVE TO have a
# `parse` function as an entry point.
      parse: (file) ->
        @file = file
        @parseBibtex() # Actually parse the file
        @normalizeTags() # Normalize entries tags (lowercase, etc.)
        @toBibJson() # Do more work to match the bibjson scheme
        return @parsedBibliography

      parseBibtex: ->
# You do an asynchronous AJAX request to get the bibliography file. Asynchrounous is mandatory as we
# can't go further until the file is loaded. It's not recommended but I don't see other solution.
# Feel free to propose.
        $.ajax({
          async: false,
          url: @file,
          success: (data) =>
# Once loaded, the content of the file is passed as argument to the success function. Now, you call
# the bibtexParse library to parse our bibtex stream to JSON. But this JSON doesn't follow the
# bibjson schema...
            @parsedBibliography = bibtexParse.toJSON(data)
        })

      normalizeTags: () ->
# Lower case tag names
        for entry in @parsedBibliography
          entry.entryType = entry.entryType.toLowerCase()
          for key, value of entry.entryTags
            if key isnt key.toLowerCase()
              entry.entryTags[key.toLowerCase()] = value
              delete entry.entryTags[key]

      toBibJson: () ->
# Convert the returned JSON from bibtexParse to JSON agreeing the bibjson schema.
        jsonBib = {}
        for entry in @parsedBibliography
          jsonEntry = {}
# Get the mandatory tags
          jsonEntry.id = entry.citationKey
          jsonEntry.type = entry.entryType

# bibtexParse returns the author field as is, without splitting multiple authors or whatever. Here
# we try to do the job for it.
          if entry.entryTags.author?
            jsonEntry.author = []
# Separate each author
# TODO: handle case were the separator is not 'and'
            for author in entry.entryTags.author.split(" and ")
              jsonEntry.author.push(this.parseName(@fixSpecialChars(author)))
            delete entry.entryTags.author

# Do the same for the editor field
          if entry.entryTags.editor?
            jsonEntry.editor = []
            for editor in entry.entryTags.editor.split(" and ")
              jsonEntry.editor.push(this.parseName(@fixSpecialChars(editor)))
            delete entry.entryTags.editor

# If journal is present, then add volume and pages to it
# TODO: do what is written in comments ;-)
          if entry.entryTags.journal?
            jsonEntry.journal = {
              name: @fixSpecialChars(entry.entryTags.journal),
            }
            delete entry.entryTags.journal

# Finally, add the other fields
          for key, value of entry.entryTags
            jsonEntry[key] = @fixSpecialChars(value)

# Add it in an object
          jsonBib[jsonEntry.id] = jsonEntry
# Save the dictionary
        @parsedBibliography = jsonBib

      fixSpecialChars: (text) ->
        for specialChar in BibliographyParserBibtex.specialChars
          text = text.replace(specialChar[0], specialChar[1])
        return text

    console.log("@@ Vinyl::Bibliography::Parser::BibTex @@ Initialisation: DONE")
    return BibliographyParserBibtex
)

# This is an example of a parser. Feel free to add others to handle many different file formats.
