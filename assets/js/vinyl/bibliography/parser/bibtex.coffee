---
---

# This is the first parser implemented. It relies on a dependancy: bibtexParse.
# This parser parse bibtex files, likes the ones generated by Jabref or Zotero.
#
# Be aware that bibtexParse library is not perfect and some special content added by Jabref (for
# example groups) are not supported.

define(
  [
    'bibtexParse',
    './abstract'
  ],
  (bibtexParse, BibliographyParserAbstract) ->
    console.log("@@ Vinyl::Bibliography::Parser::BibTex @@ Initialisation...")
# Let's start extending the abstract base class
    class BibliographyParserBibtex extends BibliographyParserAbstract
      @specialChars = [
        #[/(?<!\)({|})/, ''],
        [/\\%({})?/g, '%'],
        [/\\\$({})?/g, '$'],
        [/\\_({})?/g, '_'],
        [/\\P({})?/g, ''], # TODO
        [/\\ddag({})?/g, ''], #TODO
        [/\\textbar({})?/g, '|'],
        [/\\textgreater({})?/g, '&gt;'],
        [/\\textendash({})?/g, '&ndash;'],
        [/\\texttrademark({})?/g, ''], #TODO
        [/\\textexclamdown({})?/g, '¡'],
        [/\\textsuperscript{(\w*)}/g, '<sup>$1</sup>'],
        [/\\pounds({})?/g, '£'],
        [/\\#({})?/g, '#'],
        [/\\&({})?/g, '&amp;'],
        [/\\S({})?/g, '§'],
        [/\\dag({})?/g, ''], #TODO
        [/\\textbackslash({})?/g, '\\'],
        [/\\textless({})?/g, '&lt;'],
        [/\\textemdash({})?/g, '&mdash;'],
        [/\\textregistered({})?/g, ''], # TODO
        [/\\textquestiondown({})?/g, '¿'],
        [/\\textcircled{(\w*)}/g, '$1'], #TODO
        [/\\textcopyright({})?/g, ''], #TODO
        [/\\textasciitilde{}/g, '~'],
        [/---/g, '&mdash;'],
        [/--/g, '&ndash;'],
        [/`(.*?)'/g, '<q>$1</q>'],
        # Diacritics
        [/\\`{(.?)}/g, '$1&#x0300;'],
        [/\\'{(.?)}/g, '$1&#x0301;'],
        [/\\\^{(.?)}/g, '$1&#x0302;'],
        [/\\"{(.?)}/g, '$1&#x0308;'],
        [/\\~{(.?)}/g, '$1&#x0303;'],
        [/~/g, '&nbsp;'],
        [/\\={(.?)}/g, '$1&#x0304;'],
        [/\\\.{(.?)}/g, '$1&#x0307;'],
        [/\\u{(.?)}/g, '$1&#x0306;'],
        [/\\v{(.?)}/g, '$1&#x030C;'],
        [/\\H{(.?)}/g, '$1&#x030B;'],
        [/\\t{(.)(.)}/g, '$1&#x0361;$2'],
        [/\\c{(.?)}/g, '$1&#x0327;'],
        [/\\d{(.?)}/g, '$1&#x0323;'],
        [/\\b{(.?)}/g, '$1&#x0331;'],
        [/\\k{(.?)}/g, '$1&#x0328;'],
        [/\\r{(.?)}/g, '$1&#x030A;'],
        [/\\oe({})?/g, '&#x0153;'],
        [/\\OE({})?/g, '&#x0152;'],
        [/\\ae({})?/g, '&#x00e6;'],
        [/\\AE({})?/g, '&#x00c6;'],
        [/\\aa({})?/g, 'a&#x030A;'],
        [/\\AA({})?/g, 'A&#x030A;'],
        [/\\o({})?/g, 'o&#x337;'],
        [/\\O({})?/g, 'O&#x337;'],
        [/\\l({})?/g, 'l&#x0335;'],
        [/\\L({})?/g, 'L&#x0335;'],
        [/\\ss({})?/g, '&#x00DF;']
      ]
      @allBraces = [
        [/([^\\])({|})/g, '$1'],
        [/^{/g, ''],
        [/\\{/g, '{'],
        [/\\}/g, '}']
      ]
      @literalBraces = [
        [/\\{/g, '{'],
        [/\\}/g, '}']
      ]

      constructor: () ->
        super("BibliographyParserBibtex")

# Implement/override the mandatory `parse` function.
# Then you can define as many functions as you want to do the actual job, but you HAVE TO have a
# `parse` function as an entry point.
      parse: (file) ->
        @file = file
        @parseBibtex() # Actually parse the file
        @normalizeTags() # Normalize entries tags (lowercase, etc.)
        @toBibJson() # Do more work to match the bibjson scheme
        return @parsedBibliography

      parseBibtex: ->
# You do an asynchronous AJAX request to get the bibliography file. Asynchrounous is mandatory as we
# can't go further until the file is loaded. It's not recommended but I don't see other solution.
# Feel free to propose.
        $.ajax({
          async: false,
          url: @file,
          success: (data) =>
# Once loaded, the content of the file is passed as argument to the success function. Now, you call
# the bibtexParse library to parse our bibtex stream to JSON. But this JSON doesn't follow the
# bibjson schema...
            @parsedBibliography = bibtexParse.toJSON(data)
        })

      normalizeTags: () ->
# Lower case tag names
        for entry in @parsedBibliography
          entry.entryType = entry.entryType.toLowerCase()
          for key, value of entry.entryTags
            if key isnt key.toLowerCase()
              entry.entryTags[key.toLowerCase()] = value
              delete entry.entryTags[key]

      toBibJson: () ->
# Convert the returned JSON from bibtexParse to JSON agreeing the bibjson schema.
        jsonBib = {}
        for entry in @parsedBibliography
          if entry.entryType == "comment"
            continue
          jsonEntry = {}
# Get the mandatory tags
          jsonEntry.id = entry.citationKey
          jsonEntry.type = entry.entryType

# bibtexParse returns the author field as is, without splitting multiple authors or whatever. Here
# we try to do the job for it.
          if entry.entryTags.author?
            jsonEntry.author = []
# Separate each author
# TODO: handle case were the separator is not 'and'
            for author in entry.entryTags.author.split(" and ")
              jsonEntry.author.push(this.parseName(@fixSpecialChars(author, false)))
            delete entry.entryTags.author

# Do the same for the editor field
          if entry.entryTags.editor?
            jsonEntry.editor = []
            for editor in entry.entryTags.editor.split(" and ")
              jsonEntry.editor.push(this.parseName(@fixSpecialChars(editor, false)))
            delete entry.entryTags.editor

# If journal is present, then add volume and pages to it
# TODO: do what is written in comments ;-)
          if entry.entryTags.journal?
            jsonEntry.journal = {
              name: @fixSpecialChars(entry.entryTags.journal, true),
            }
            delete entry.entryTags.journal

# Finally, add the other fields
          for key, value of entry.entryTags
            jsonEntry[key] = @fixSpecialChars(value, true)

# Add it in an object
          jsonBib[jsonEntry.id] = jsonEntry
# Save the dictionary
        @parsedBibliography = jsonBib

      fixSpecialChars: (text, removeBraces) ->
        for specialChar in BibliographyParserBibtex.specialChars
          text = text.replace(specialChar[0], specialChar[1])
        for brace in (if removeBraces then BibliographyParserBibtex.allBraces else BibliographyParserBibtex.literalBraces)
          text = text.replace(brace[0], brace[1])
        return text

    console.log("@@ Vinyl::Bibliography::Parser::BibTex @@ Initialisation: DONE")
    return BibliographyParserBibtex
)

# This is an example of a parser. Feel free to add others to handle many different file formats.
